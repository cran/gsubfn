99,106c99,101
< is called with one argument per backreference or if no backreferences
< with the match (unless instructed otherwise 
< by the \code{backref} argument). Note that it determines the number of
< backreferences by counting the number of occurrences of \code{(} in the 
< regular expression so if there are parentheses that are not
< back references it may be important to specify their number explicitly with
< \code{backref}.
< The output of the replacement function is 
---
> is called with input arguments being the match followed by one argument
> per back reference (unless instructed otherwise 
> by the \code{backref} argument). The output of the replacement function is 
240a236,237
> \code{backref = -2} tells \code{gsubfn} to only pass the 2 back references 
> and not the match itself to the replacement function.  
244,245d240
< This example replaces the scale letter with an appropriate scale factor.
< For example, \code{"G"} means giga and corresponds to \code{"e9"}.
249c244
<    gsubfn('([0-9]+):([0-9]+)', ~ as.numeric(x) + as.numeric(y), s)
---
>    gsubfn('([0-9]+):([0-9]+)', ~ as.numeric(x) + as.numeric(y), s, backref = -2)
251a247,250
> \textit{Example}. 
> This example replaces the scale letter with an appropriate scale factor.
> For example, \code{"G"} means giga and corresponds to \code{"e9"}.
> 
260,276d258
< \section[gsubfn with lists]{\code{gsubfn} with \code{list} objects}
< \label{sec:gsubfn with list objects}
< 
< \textit{Example}. 
< If the replacement object is a list then the match is matched against the
< names of the list and the corresponding value is returned. If no name
< matches then the first unnamed list component is returned.  If there is
< still no match then the string to be matched is returned so that effectively
< the lookup is ignored.
< 
< Here is the last example redone with a list:
< 
< <<gsubfn-si>>=
<    dat <- c('3.5G', '88P', '19') # test data
<    gsubfn('[MGP]', list(M = 'e6', G = 'e9', P = 'e12'), dat) 
< @
< 
314c296
< method/function.
---
> method/functin.
407,408c389,390
< To separate out the initial digits from the rest returning the 
< the initial digits and the rest as two separate fields we can write this:
---
> To separate out the initial digits from the rest returning the whole 
> string, the initial digits and the rest as three separate fields we can write this:
415,417c397
< In this example we calculate the midpoint of each interval.  The \code{()}
< will fool it into thinking there is a back reference so specify \code{backref}
< explicitly telling it to pass the match.
---
> In this example we calculate the midpoint of each interval.
420c400
< colMeans(strapply(rn, "[^][(),]+", as.numeric, backref = 0, simplify = TRUE))
---
> colMeans(strapply(rn, "[^][(),]+", as.numeric, simplify = TRUE))
469,474c449
< retrieves overlapping segments consisting of a space, letter, space, letter
< and space.  Only the final space, letter, space is returned.
< Because we did not specify \code{backref} it will think there are two
< back references (since it will interpret the lookahead expression as
< an extra back reference); however, the second is empty so it does no harm in
< passing it to \code{paste0}.
---
> retrieves overlapping segments consisting of a letter, space and letter.
